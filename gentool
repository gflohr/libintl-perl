#! /usr/bin/perl -w

# vim: set et sw=4 ts=4:

# This file is part of libintl-perl
# Copyright (C) 2002-2011 Guido Flohr <guido@imperia.net>,
# all rights reserved.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.

# You should have received a copy of the GNU Library General Public
# License along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
# USA.

# This script generates a libintl-perl tool from a module, including
# documentation and usage string.  The script only understands a 
# subset of POD!

use strict;

sub trim;
sub format_over;
sub escaped_length;

my ($module, $script) = @ARGV;

die "Usage: $0 MODULE [SCRIPTNAME]\n" unless defined $module && length $module;

open HANDLE, "<$module" or die "$0: Cannot read `$0': $!\n";
my $module_content = join '', <HANDLE>;

die "Input file `$module' has no NAME section!\n"
	unless $module_content =~ /\n=head1[ \t]+NAME(.*?)\n=head1/s;
my $name = trim $1;

die "Input file `$module' has no SYNOPSIS section!\n"
	unless $module_content =~ /\n=head1 SYNOPSIS(.*?)\n=head1/s;
my $synopsis = trim $1;

die "Input file `$module' has no DESCRIPTION section!\n"
	unless $module_content =~ /\n=head1 DESCRIPTION(.*?)\n=head1/s;
my $description = trim $1;

my $bugs;
if ($module_content =~ /\n=head1 BUGS(.*?)\n=head1/s) {
	$bugs = trim $1;
}

# Copy the copyright header to the output script.
open HANDLE, "<$0" or die "$0: Cannot read `$0': $!\n";
while (<HANDLE>) {
        last if /^use strict;[ \t\r\n]*$/;
        print;
}
close HANDLE;

my $class = $module;
$class =~ s{^(?:\./)?lib/}{};
$class =~ s{[/\\]}{::}g;
$class =~ s/\.pm$//;

unless (defined $script && length $script) {
        $script = $class;
        $script =~ s/.*::/p/;
        $script = lc $script;
}

print <<EOF;
use strict;

use Locale::TextDomain qw ('libintl-perl');
use $class;

EOF

my $pod = '';
my $usage = '';

my $options = $synopsis;
$options =~ s/^[ \t]*//;
$options =~ s/[ \t]*$//;
unless ($options =~ s{^$class->new->run[ \t]*\((.*)\);.*}{$1}) {
        die "$module: SYNOPSIS section not properly formatted!\n";
}
$options =~ y/,//d;

$usage .= <<EOF;
\$__{'$script $options'}
EOF

$pod .= <<EOF;
=head1 SYNOPSIS

  $script $options

=head1 DESCRIPTION
$description
EOF

$pod .= "\n=head1 BUGS\n\n$bugs\n" if defined $bugs && length $bugs;

# Now format the description as a usage string.
$description =~ s/B<(.*?)>/$1/gs;
my %escapes = ('\\' => '\\\\', '\'' => '\\\'');
$description =~ s/([\\\'])/$escapes{$1}/gs;
$description =~ s/\n=over[ \t]+[1-9][0-9]*(.*?)\n=back/format_over trim $1/egs;

my @chunks = split /\n[ \t\r\n]*\n/, $description;
$description = join "\n\n", map { s/[ \t]+$//; q[$__{'] . $_ . q['}]} @chunks;

$usage .= "\n$description";

$usage = trim $usage;
$usage =~ s/[ \t]+$//s;

print <<EOFF;
\$${class}::usage = <<EOF;
$usage
EOF

$class->new->run(\@ARGV);

__END__

EOFF

$pod .= <<EOF;

=head1 COPYRIGHT

Copyright (C) 1995-2011 Guido Flohr <guido\@imperia.net>, all rights reserved.

=head1 SEE ALSO

$class(3pm), perl(1)

EOF

print $pod;

sub trim {
	my ($string) = @_;

	$string =~ s/^[ \t\r\n]+//s;
	$string =~ s/[ \t\r\n]+$//s;

	return $string;
}

sub format_over {
	my ($string) = @_;

	my @chunks = split /(\n=item(?:[^\n]*))/, "\n$string";
	
	my $retval = '';
	while (@chunks) {
		last if ($chunks[0] =~ /\n=item(?:[^\n]*)/s);
		shift @chunks;
	}

	for (my $i = 0; $i < @chunks; $i += 2) {
        my $options = $chunks[$i];
		$options =~ s/^\n=item//;
		$options =~ s/,[ \t]+(?!-)/ /g;
		$options = trim $options;

		my $line = "  $options";
        my $l = escaped_length $line;
        if ($l >= 29) {
            $retval .= $line . "\n";
            $line = ' ' x 29;
        } else {
            $line .= ' ' x (29 - $l);
        }

		my @words = split /[ \t\r\n]+/, trim $chunks[$i + 1];

        foreach my $word (@words) {
            my $eos = ('.' eq substr $line, -1, 1) ? ' ' : '';
            if (79 > escaped_length "$line$eos$word") {
                $line .= ' ' . $eos . $word;
                next;
            }
            $retval .= $line . "\n";
            $line = ' ' x 30;
            $line .= $word;
        }
        $retval .= $line if length $line;
        chomp $retval;
        $retval .= "\n";
	}

	return $retval;
}

sub escaped_length {
    my ($string) = @_;
    
    my $retval = length $string;
    while ($string =~ /\G.*?\\[\\']/g) {
        --$retval;
    }
    
    return $retval;
}   

1;

