#! /usr/local/bin/perl -w
# vim: tabstop=4

# Benchmark conversion routines.
# Copyright (C) 2002-2003 Guido Flohr <guido@imperia.net>, all rights reserved.
# $Id: test-benchmark,v 1.5 2003/06/02 11:16:54 guido Exp $

# Distribution either under the terms of the Artistic license (see
# Artistic) or - at your choice - under the terms and conditions of
# the GNU General Public License described below.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

use strict;

use Benchmark;

use constant COUNT_TINY  => 200_000;
use constant BYTES_TINY  => 10;
use constant COUNT_SMALL => 20_000;
use constant BYTES_SMALL => 100;
use constant COUNT_LARGE => 20;
use constant BYTES_LARGE => 100 * 1024;

BEGIN {
	my $here = $0;
	$here =~ s,.*[\\/],, or $here = '.';
	unshift @INC, $here;
}

require Locale::Iconv;

# These codesets have been taken for the following reasons:
#
# - the conversion modules here are generated
# - ISO-8859-2 is mostly a subset of Windows-1250 and
#   therefore the conversion routines based on iconv(3)
#   cannot fail.
# - inside the common subset, the conversion is always
#   reversible.
#
use vars qw ($from $to);
$from = 'ISO-8859-2';
$to   = 'Windows-1250';

my @valid_codes = map chr, (0x00 .. 0x7f, 0xa0 .. 0xff);

use vars qw ($tiny_buf $small_buf $large_buf);
$tiny_buf  = '';
$small_buf = '';
$large_buf = '';

$| = 1;
print "generating test strings...";
for (0 .. BYTES_TINY) {
	$tiny_buf .= $valid_codes[int rand @valid_codes];
}
for (0 .. BYTES_SMALL) {
	$small_buf .= $valid_codes[int rand @valid_codes];
}
for (0 .. BYTES_LARGE) {
	$large_buf .= $valid_codes[int rand @valid_codes];
}
print "done\n";

use vars qw ($cd1);
$cd1 = Locale::Iconv->new (from => $from,
			   to   => $to); 

if ($cd1) {
	timethese COUNT_TINY, {
		"a @{[ BYTES_TINY ]} bytes buffer conversion" =>
			'$cd1->recode ($tiny_buf)' };
	timethese COUNT_SMALL, { 
		"a @{[ BYTES_SMALL ]} bytes buffer conversion" =>
			'$cd1->recode ($small_buf)' };
	timethese COUNT_LARGE, {
		"a @{[ BYTES_LARGE ]} bytes buffer conversion" =>
			'$cd1->recode ($large_buf)' };

	print "Non-cached version\n";
	timethese COUNT_TINY, {
		"a @{[ BYTES_TINY ]} bytes buffer conversion" =>
			'Locale::Iconv->new(from => $from, to => $to)->recode($tiny_buf)' };
	timethese COUNT_SMALL, { 
		"a @{[ BYTES_SMALL ]} bytes buffer conversion" =>
			'Locale::Iconv->new(from => $from, to => $to)->recode($small_buf)' };
	timethese COUNT_LARGE, {
		"a @{[ BYTES_LARGE ]} bytes buffer conversion" =>
			'Locale::Iconv->new(from => $from, to => $to)->recode($large_buf)' };
} else {
	warn "cannot convert from $from to $to :-(\n";
}

# Run against Text::Iconv if available.
eval "require Text::Iconv";
use vars '$converter';
unless ($@) {
	if ($converter = Text::Iconv->new ($from => $to)) {
		print "comparing to Text::Iconv::iconv()\n";
		print "(attention: doing ten times as much as the Perl version)\n";	
		timethese 10 * COUNT_TINY, {
			"a @{[ BYTES_TINY ]} bytes buffer conversion" =>
				'my $r = $converter->convert ($tiny_buf)' };
		timethese 10 * COUNT_SMALL, { 
			"a @{[ BYTES_SMALL ]} bytes buffer conversion" =>
				'my $r = $converter->convert ($small_buf)' };
		timethese 10 * COUNT_LARGE, {
			"a @{[ BYTES_LARGE ]} bytes buffer conversion" =>
				'my $r = $converter->convert ($large_buf)' };

		print "comparing to Text::Iconv::iconv() (non-cached conversion)\n";
		print "(attention: doing ten times as much as the Perl version)\n";	
		timethese 10 * COUNT_TINY, {
			"a @{[ BYTES_TINY ]} bytes buffer conversion" =>
				'my $r = Text::Iconv->new($from, $to)->convert ($tiny_buf)' };
		timethese 10 * COUNT_SMALL, { 
			"a @{[ BYTES_SMALL ]} bytes buffer conversion" =>
				'my $r = Text::Iconv->new($from, $to)->convert ($small_buf)' };
		timethese 10 * COUNT_LARGE, {
			"a @{[ BYTES_LARGE ]} bytes buffer conversion" =>
				'my $r = Text::Iconv->new($from, $to)->convert ($large_buf)' };
	}
}

# Run against Encode if available.
eval "require Encode";
unless ($@) {
		print "comparing to Encode::from_to()\n";
		#print "(attention: doing ten times as much as the Perl version)\n";	
		timethese COUNT_TINY, {
			"a @{[ BYTES_TINY ]} bytes buffer conversion" =>
				'Encode::from_to ($tiny_buf, $from, $to)' };
		timethese COUNT_SMALL, { 
			"a @{[ BYTES_SMALL ]} bytes buffer conversion" =>
				'Encode::from_to ($small_buf, $from, $to)' };
		timethese COUNT_LARGE, {
			"a @{[ BYTES_LARGE ]} bytes buffer conversion" =>
				'Encode::from_to ($large_buf, $from, $to)' };
}

__END__

Local Variables:
mode: perl
perl-indent-level: 4
perl-continued-statement-offset: 4
perl-continued-brace-offset: 0
perl-brace-offset: -4
perl-brace-imaginary-offset: 0
perl-label-offset: -4
cperl-indent-level: 4
cperl-continued-statement-offset: 2
tab-width: 4
End:

=head1 NAME

Locale::Iconv

=head1 SYNOPSIS

use Locale::Iconv qw (iconv_open iconv iconv_close recode);

$cd = Locale::Iconv->new (from => 'UTF-8',
                          to   => 'ISO-8859-1',
                          unknown => chr '?',
                          illegal => chr '?',
                         );

die $cd->getError if $cd->getError;

$cd->recode ($text) or
    die $cd->getError;

$irreversible = $cd->iconv ($text, $inbytes_left,
                            $converted, $outbytes_left);

die $cd->getError if $cd->getError;

$cd = iconv_open ('ISO-8859-1', 'UTF-8');

recode ($cd, $text) or
    die $Locale::Iconv::getError();

$irreversible = iconv ($cd, $text, $inbytes_left, 
                       $converted, $outbytes_left);

die $Locale::Iconv::getError() if $irreversible == -1;

iconv_close ($cd);

=head1 DESCRIPTION

This module provides routines that convert textual data from one
codeset to another.  

=head1 AUTHOR

Copyright (C) 2002-2003, Guido Flohr E<lt>guido@imperia.netE<gt>, all
rights reserved.  See the source code for details.

This software is contributed to the Perl community by Imperia 
(http://www.imperia.net/).

=head1 SEE ALSO

iconv(3), iconv(1), perl(1)

